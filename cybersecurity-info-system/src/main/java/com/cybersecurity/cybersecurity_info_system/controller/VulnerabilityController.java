package com.cybersecurity.cybersecurity_info_system.controller;

import com.cybersecurity.cybersecurity_info_system.entity.*;
import com.cybersecurity.cybersecurity_info_system.repository.*;
import com.cybersecurity.cybersecurity_info_system.service.AlertService;
import jakarta.validation.Valid;
import org.hibernate.Hibernate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.ui.Model;
import org.springframework.util.StringUtils;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import java.util.List;

@Controller
@RequestMapping("/vulnerabilities")
@PreAuthorize("hasRole('ADMIN') OR hasRole('ANALYST')")
public class VulnerabilityController {

    @Autowired private VulnerabilityRepository vulnerabilityRepo;
    @Autowired private AssetRepository assetRepo;
    @Autowired private UserRepository userRepo;
    @Autowired private AlertService alertService; // NEW: Auto-create alerts

    @GetMapping
    @Transactional(readOnly = true)
    public String list(Model model, Authentication auth) {
        List<Vulnerability> vulnerabilities = vulnerabilityRepo.findAll();
        List<Asset> assets = assetRepo.findAll();
        List<User> analysts = userRepo.findByRole(User.Role.ANALYST);

        // Prevent LazyInitializationException
        vulnerabilities.forEach(v -> {
            Hibernate.initialize(v.getAffectedAsset());
            Hibernate.initialize(v.getReportedBy());
            Hibernate.initialize(v.getAssignedTo());
        });

        User currentUser = getCurrentUser(auth);
        if (currentUser == null) {
            return "redirect:/login";
        }

        model.addAttribute("vulnerabilities", vulnerabilities);
        model.addAttribute("assets", assets);
        model.addAttribute("analysts", analysts);
        model.addAttribute("currentUser", currentUser);
        model.addAttribute("newVuln", new Vulnerability());
        model.addAttribute("updatedVuln", new Vulnerability()); // For edit modal

        return "vulnerabilities";
    }

    @PostMapping("/add")
    public String add(@Valid @ModelAttribute("newVuln") Vulnerability vuln,
                      BindingResult result,
                      @RequestParam(required = false) Long affectedAssetId,
                      @RequestParam(required = false) Long assignedToId,
                      Authentication auth,
                      RedirectAttributes redirect) {

        if (result.hasErrors()) {
            redirect.addFlashAttribute("error", "Please fill all required fields correctly.");
            return "redirect:/vulnerabilities";
        }

        User reporter = getCurrentUser(auth);
        if (reporter == null) {
            redirect.addFlashAttribute("error", "Authentication failed. Please log in.");
            return "redirect:/login";
        }

        vuln.setReportedBy(reporter);
        vuln.setStatus(Vulnerability.Status.OPEN);

        if (affectedAssetId != null && affectedAssetId > 0) {
            assetRepo.findById(affectedAssetId)
                    .ifPresentOrElse(vuln::setAffectedAsset,
                            () -> redirect.addFlashAttribute("error", "Selected asset does not exist."));
        }

        if (assignedToId != null && assignedToId > 0) {
            userRepo.findById(assignedToId)
                    .ifPresentOrElse(vuln::setAssignedTo,
                            () -> redirect.addFlashAttribute("error", "Selected analyst does not exist."));
        }

        try {
            vulnerabilityRepo.save(vuln);

            // CREATE ALERT
            alertService.createVulnerabilityAlert(vuln.getId(), vuln.getTitle(), vuln.getSeverity());

            redirect.addFlashAttribute("message", "Vulnerability '" + vuln.getTitle() + "' reported successfully!");
        } catch (Exception e) {
            redirect.addFlashAttribute("error", "Failed to save vulnerability. Please try again.");
        }

        return "redirect:/vulnerabilities";
    }

    @PostMapping("/status/{id}")
    public String updateStatus(@PathVariable Long id,
                               @RequestParam String status,
                               RedirectAttributes redirect) {
        return vulnerabilityRepo.findById(id)
                .map(vuln -> {
                    try {
                        Vulnerability.Status newStatus = Vulnerability.Status.valueOf(status.toUpperCase());
                        vuln.setStatus(newStatus);
                        vulnerabilityRepo.save(vuln);
                        redirect.addFlashAttribute("message", "Status updated to " + newStatus.getDisplayName() + ".");
                    } catch (IllegalArgumentException e) {
                        redirect.addFlashAttribute("error", "Invalid status: '" + status + "'.");
                    }
                    return "redirect:/vulnerabilities";
                })
                .orElseGet(() -> {
                    redirect.addFlashAttribute("error", "Vulnerability not found.");
                    return "redirect:/vulnerabilities";
                });
    }

    @PostMapping("/update/{id}")
    public String update(@PathVariable Long id,
                         @Valid @ModelAttribute("updatedVuln") Vulnerability updated,
                         BindingResult result,
                         @RequestParam(required = false) Long affectedAssetId,
                         @RequestParam(required = false) Long assignedToId,
                         RedirectAttributes redirect) {

        if (result.hasErrors()) {
            redirect.addFlashAttribute("error", "Please correct the highlighted errors.");
            return "redirect:/vulnerabilities";
        }

        return vulnerabilityRepo.findById(id)
                .map(vuln -> {
                    // SAFE TRIM using StringUtils
                    vuln.setTitle(StringUtils.trimWhitespace(updated.getTitle()));
                    vuln.setDescription(StringUtils.trimWhitespace(updated.getDescription()));
                    vuln.setSeverity(updated.getSeverity());
                    vuln.setStatus(updated.getStatus());

                    // Update Asset
                    if (affectedAssetId != null && affectedAssetId > 0) {
                        assetRepo.findById(affectedAssetId)
                                .ifPresentOrElse(vuln::setAffectedAsset,
                                        () -> redirect.addFlashAttribute("error", "Invalid asset selected."));
                    } else {
                        vuln.setAffectedAsset(null);
                    }

                    // Update Assigned To
                    if (assignedToId != null && assignedToId > 0) {
                        userRepo.findById(assignedToId)
                                .ifPresentOrElse(vuln::setAssignedTo,
                                        () -> redirect.addFlashAttribute("error", "Invalid analyst selected."));
                    } else {
                        vuln.setAssignedTo(null);
                    }

                    try {
                        vulnerabilityRepo.save(vuln);
                        redirect.addFlashAttribute("message", "Vulnerability updated successfully.");
                    } catch (Exception e) {
                        redirect.addFlashAttribute("error", "Update failed. Please try again.");
                    }
                    return "redirect:/vulnerabilities";
                })
                .orElseGet(() -> {
                    redirect.addFlashAttribute("error", "Vulnerability not found.");
                    return "redirect:/vulnerabilities";
                });
    }

    @PostMapping("/delete/{id}")
    @Transactional
    public String delete(@PathVariable Long id, RedirectAttributes redirect) {
        if (!vulnerabilityRepo.existsById(id)) {
            redirect.addFlashAttribute("error", "Vulnerability not found.");
            return "redirect:/vulnerabilities";
        }

        try {
            Vulnerability v = vulnerabilityRepo.getReferenceById(id);
            String title = v.getTitle() != null ? v.getTitle() : "ID:" + id;
            vulnerabilityRepo.deleteById(id);
            redirect.addFlashAttribute("message", "Vulnerability '" + title + "' deleted.");
        } catch (DataIntegrityViolationException e) {
            redirect.addFlashAttribute("error", "Cannot delete: Vulnerability is referenced in incidents or reports.");
        } catch (Exception e) {
            redirect.addFlashAttribute("error", "Delete failed. Please try again.");
        }

        return "redirect:/vulnerabilities";
    }

    // HELPER: Get current User entity
    private User getCurrentUser(Authentication auth) {
        if (auth == null || auth.getPrincipal() == null) return null;
        if (auth.getPrincipal() instanceof UserDetails userDetails) {
            return userRepo.findByUsername(userDetails.getUsername()).orElse(null);
        }
        return null;
    }
}